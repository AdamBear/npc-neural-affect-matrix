<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPC Neural Affect Matrix - Web API æµ‹è¯•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .status.connected {
            background: #10b981;
            color: white;
        }

        .status.disconnected {
            background: #ef4444;
            color: white;
        }

        .status.waiting {
            background: #f59e0b;
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }

        .response-box {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .response-box pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .emotion-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .emotion-item {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .emotion-item .label {
            font-size: 0.9em;
            color: #6b7280;
            margin-bottom: 5px;
        }

        .emotion-item .value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .emotion-meter {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .emotion-meter-fill {
            height: 100%;
            transition: width 0.5s, background 0.5s;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }

            .emotion-display {
                grid-template-columns: 1fr;
            }
        }

        .npc-list {
            list-style: none;
        }

        .npc-list li {
            background: #f3f4f6;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .npc-list li.active {
            background: #dbeafe;
            border: 2px solid #667eea;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-info {
            background: #dbeafe;
            color: #1e40af;
        }

        .log {
            background: #1f2937;
            color: #10b981;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-time {
            color: #6b7280;
        }

        /* æ”¹è¿›çš„æƒ…ç»ªç¯æ ·å¼ */
        .circumplex-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            position: relative;
        }

        .circumplex {
            width: 500px;
            height: 500px;
            position: relative;
            border-radius: 50%;
            background:
                radial-gradient(circle at 50% 50%,
                    rgba(255, 255, 255, 0.3) 0%,
                    rgba(255, 255, 255, 0) 70%
                ),
                conic-gradient(from 45deg,
                    #fca5a5 0deg,    /* å·¦ä¸Š - è´Ÿé¢é«˜å”¤é†’ (çº¢è‰²) */
                    #fde68a 90deg,   /* ä¸Š - ä¸­æ€§é«˜å”¤é†’ (é»„è‰²) */
                    #86efac 180deg,  /* å³ä¸Š - æ­£é¢é«˜å”¤é†’ (ç»¿è‰²) */
                    #7dd3fc 225deg,  /* å³ - æ­£é¢ä¸­å”¤é†’ (é’è‰²) */
                    #93c5fd 270deg,  /* å³ä¸‹ - æ­£é¢ä½å”¤é†’ (è“è‰²) */
                    #d1d5db 315deg,  /* ä¸‹ - ä¸­æ€§ä½å”¤é†’ (ç°è‰²) */
                    #fca5a5 360deg   /* å·¦ä¸‹å›åˆ°å·¦ä¸Š (çº¢è‰²) */
                );
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* ä¸­å¿ƒç½‘æ ¼çº¿ */
        .circumplex::before,
        .circumplex::after {
            content: '';
            position: absolute;
            background: rgba(0,0,0,0.1);
        }

        .circumplex::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .circumplex::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* æƒ…ç»ªç‚¹ */
        .emotion-point {
            width: 24px;
            height: 24px;
            background: #667eea;
            border: 4px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
            cursor: pointer;
            z-index: 10;
        }

        .emotion-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.8);
        }

        /* ä¸»è½´æ ‡ç­¾ - æ›´å¤§æ›´ç²— */
        .axis-label {
            position: absolute;
            font-weight: 700;
            font-size: 1.15em;
            color: #1f2937;
            text-shadow: none;
        }

        .axis-label.top {
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
        }

        .axis-label.bottom {
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
        }

        .axis-label.left {
            left: -70px;
            top: 50%;
            transform: translateY(-50%);
        }

        .axis-label.right {
            right: -70px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* æƒ…ç»ªæ ‡ç­¾ */
        .emotion-label {
            position: absolute;
            font-size: 0.9em;
            font-weight: 500;
            color: #374151;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            white-space: nowrap;
        }

        /* Converted from reference SVG coordinates (700x700 -> 500x500) */
        /* Reference: center (350,350), radius 270 */

        /* Excited: x=453, y=63 -> 64.7%, 9% */
        .emotion-label.excited { top: 9%; left: 64.7%; transform: translateX(-50%); }

        /* Delighted: x=616, y=156 -> 88%, 22% */
        .emotion-label.delighted { top: 22%; left: 88%; transform: translateX(-50%); }

        /* Happy: x=673, y=289 -> 96%, 41% */
        .emotion-label.happy { top: 41%; left: 96%; transform: translateX(-50%); }

        /* Content: x=673, y=410 -> 96%, 58% */
        .emotion-label.content { top: 58%; left: 96%; transform: translateX(-50%); }

        /* Relaxed: x=616, y=543 -> 88%, 77% */
        .emotion-label.relaxed { top: 77%; left: 88%; transform: translateX(-50%); }

        /* Calm: x=453, y=636 -> 64.7%, 90% */
        .emotion-label.calm { top: 90%; left: 64.7%; transform: translateX(-50%); }

        /* Tired: x=246, y=636 -> 35%, 90% */
        .emotion-label.tired { top: 90%; left: 35%; transform: translateX(-50%); }

        /* Bored: x=83, y=543 -> 12%, 77% */
        .emotion-label.bored { top: 77%; left: 12%; transform: translateX(-50%); }

        /* Depressed: x=26, y=410 -> 4%, 58% */
        .emotion-label.depressed { top: 58%; left: 4%; transform: translateX(-50%); }

        /* Frustrated: x=26, y=289 -> 4%, 41% */
        .emotion-label.frustrated { top: 41%; left: 4%; transform: translateX(-50%); }

        /* Angry: x=83, y=156 -> 12%, 22% */
        .emotion-label.angry { top: 22%; left: 12%; transform: translateX(-50%); }

        /* Tense: x=246, y=63 -> 35%, 9% */
        .emotion-label.tense { top: 9%; left: 35%; transform: translateX(-50%); }

        /* æ‚¬æµ®ä¿¡æ¯å¡ */
        .emotion-tooltip {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 0.95em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            min-width: 160px;
        }

        .emotion-tooltip.visible {
            opacity: 1;
        }

        .emotion-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            gap: 20px;
        }

        .emotion-tooltip-row:last-child {
            margin-bottom: 0;
        }

        .emotion-tooltip-label {
            font-weight: 600;
            color: #9ca3af;
        }

        .emotion-tooltip-value {
            font-weight: 700;
            font-size: 1.2em;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§  NPC Neural Affect Matrix</h1>
            <p>Web API æµ‹è¯•ç•Œé¢</p>
        </div>

        <!-- æœåŠ¡å™¨çŠ¶æ€ -->
        <div class="card">
            <h2>ğŸ“¡ æœåŠ¡å™¨çŠ¶æ€</h2>
            <div id="server-status" class="status disconnected">æœªè¿æ¥</div>
            <div class="btn-group">
                <button class="btn-primary" onclick="checkHealth()">æ£€æŸ¥å¥åº·çŠ¶æ€</button>
                <button class="btn-success" onclick="initializeModel()">åˆå§‹åŒ–æ¨¡å‹</button>
            </div>
            <div id="health-response" class="response-box" style="display:none;">
                <pre id="health-text"></pre>
            </div>
        </div>

        <!-- NPC ç®¡ç† -->
        <div class="card">
            <h2>ğŸ‘¤ NPC ç®¡ç†</h2>

            <div class="form-group">
                <label>NPC åç§°</label>
                <input type="text" id="npc-name" placeholder="ä¾‹å¦‚: æ‘åº„å®ˆå«" value="æ‘åº„å®ˆå«">
            </div>

            <div class="form-group">
                <label>NPC èƒŒæ™¯æ•…äº‹</label>
                <textarea id="npc-background" placeholder="ä¾‹å¦‚: ä¸€ä¸ªå¿ è¯šçš„å®ˆå«ï¼Œä¿æŠ¤æ‘åº„15å¹´...">ä¸€ä¸ªå¿ è¯šçš„å®ˆå«ï¼Œä¿æŠ¤æ‘åº„å·²æœ‰15å¹´ã€‚ä»¥ç»´æŠ¤ç§©åºä¸ºè£ã€‚</textarea>
            </div>

            <div class="grid-2">
                <div class="form-group">
                    <label>Valence (æ„‰æ‚¦åº¦): <span id="valence-value">0.0</span></label>
                    <input type="range" id="npc-valence" min="-1" max="1" step="0.1" value="0.0" oninput="updateSliderValue('valence')">
                </div>

                <div class="form-group">
                    <label>Arousal (å”¤é†’åº¦): <span id="arousal-value">0.0</span></label>
                    <input type="range" id="npc-arousal" min="-1" max="1" step="0.1" value="0.0" oninput="updateSliderValue('arousal')">
                </div>
            </div>

            <div class="form-group">
                <label>è®°å¿†è¡°å‡ç‡ (0-1)</label>
                <input type="number" id="memory-decay" min="0" max="1" step="0.01" value="0.1">
            </div>

            <div class="btn-group">
                <button class="btn-success" onclick="createNPC()">åˆ›å»º NPC</button>
                <button class="btn-danger" onclick="deleteCurrentNPC()">åˆ é™¤å½“å‰ NPC</button>
                <button class="btn-primary" onclick="loadExistingNPCs()">åˆ·æ–°åˆ—è¡¨</button>
            </div>

            <div class="form-group" style="margin-top: 20px;">
                <label>é€‰æ‹© NPC</label>
                <select id="npc-select" onchange="onNPCSelectChange()" style="font-size: 1em;">
                    <option value="">-- è¯·é€‰æ‹©ä¸€ä¸ª NPC --</option>
                </select>
            </div>
        </div>

        <!-- äº¤äº’æµ‹è¯• -->
        <div class="card">
            <h2>ğŸ’¬ äº¤äº’æµ‹è¯•</h2>

            <div class="form-group">
                <label>å½“å‰ NPC ID</label>
                <input type="text" id="current-npc-id" placeholder="å…ˆåˆ›å»ºä¸€ä¸ª NPC" readonly>
            </div>

            <div class="form-group">
                <label>äº¤äº’æ–‡æœ¬</label>
                <textarea id="interaction-text" placeholder="ä¾‹å¦‚: è°¢è°¢ä½ æ•‘äº†æˆ‘çš„å‘½ï¼">è°¢è°¢ä½ æ•‘äº†æˆ‘çš„å‘½ï¼</textarea>
            </div>

            <div class="form-group">
                <label>æ¥æº ID (å¯é€‰)</label>
                <input type="text" id="source-id" placeholder="ä¾‹å¦‚: player" value="player">
            </div>

            <div class="btn-group">
                <button class="btn-primary" onclick="evaluateInteraction()">è¯„ä¼°äº¤äº’</button>
                <button class="btn-primary" onclick="getCurrentEmotion()">è·å–å½“å‰æƒ…ç»ª</button>
                <button class="btn-primary" onclick="getEmotionBySource()">è·å–ç‰¹å®šæ¥æºæƒ…ç»ª</button>
            </div>

            <!-- æƒ…ç»ªæ˜¾ç¤º -->
            <div class="emotion-display">
                <div class="emotion-item">
                    <div class="label">Valence (æ„‰æ‚¦åº¦)</div>
                    <div class="value" id="emotion-valence">--</div>
                    <div class="emotion-meter">
                        <div class="emotion-meter-fill" id="valence-meter" style="width: 50%; background: #10b981;"></div>
                    </div>
                </div>
                <div class="emotion-item">
                    <div class="label">Arousal (å”¤é†’åº¦)</div>
                    <div class="value" id="emotion-arousal">--</div>
                    <div class="emotion-meter">
                        <div class="emotion-meter-fill" id="arousal-meter" style="width: 50%; background: #f59e0b;"></div>
                    </div>
                </div>
            </div>

            <!-- æ”¹è¿›çš„æƒ…ç»ªç¯ -->
            <div class="circumplex-container">
                <div class="circumplex" id="circumplex">
                    <!-- ä¸»è½´æ ‡ç­¾ -->
                    <div class="axis-label top">é«˜å”¤é†’</div>
                    <div class="axis-label bottom">ä½å”¤é†’</div>
                    <div class="axis-label left">è´Ÿé¢</div>
                    <div class="axis-label right">æ­£é¢</div>

                    <!-- 12ä¸ªæƒ…ç»ªæ ‡ç­¾ -->
                    <div class="emotion-label excited">å…´å¥‹</div>
                    <div class="emotion-label tense">ç´§å¼ </div>
                    <div class="emotion-label angry">æ„¤æ€’</div>
                    <div class="emotion-label frustrated">æ²®ä¸§</div>
                    <div class="emotion-label depressed">æŠ‘éƒ</div>
                    <div class="emotion-label bored">æ— èŠ</div>
                    <div class="emotion-label tired">ç–²æƒ«</div>
                    <div class="emotion-label calm">å¹³é™</div>
                    <div class="emotion-label relaxed">æ”¾æ¾</div>
                    <div class="emotion-label content">æ»¡è¶³</div>
                    <div class="emotion-label happy">å¿«ä¹</div>
                    <div class="emotion-label delighted">æ„‰æ‚¦</div>

                    <!-- æƒ…ç»ªç‚¹ -->
                    <div class="emotion-point" id="emotion-point"></div>

                    <!-- æ‚¬æµ®ä¿¡æ¯å¡ -->
                    <div class="emotion-tooltip" id="emotion-tooltip">
                        <div class="emotion-tooltip-row">
                            <span class="emotion-tooltip-label">æ„‰æ‚¦åº¦:</span>
                            <span class="emotion-tooltip-value" id="tooltip-valence">0.00</span>
                        </div>
                        <div class="emotion-tooltip-row">
                            <span class="emotion-tooltip-label">å”¤é†’åº¦:</span>
                            <span class="emotion-tooltip-value" id="tooltip-arousal">0.00</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- è®°å¿†ç®¡ç† -->
        <div class="card">
            <h2>ğŸ’¾ è®°å¿†ç®¡ç†</h2>

            <div class="btn-group">
                <button class="btn-primary" onclick="getMemory()">è·å–è®°å¿†</button>
                <button class="btn-warning" onclick="clearMemory()">æ¸…é™¤è®°å¿†</button>
            </div>

            <div id="memory-response" class="response-box" style="display:none;">
                <pre id="memory-text"></pre>
            </div>
        </div>

        <!-- æ“ä½œæ—¥å¿— -->
        <div class="card">
            <h2>ğŸ“‹ æ“ä½œæ—¥å¿—</h2>
            <div id="log" class="log">
                <div class="log-entry">ç³»ç»Ÿå°±ç»ªï¼Œç­‰å¾…æ“ä½œ...</div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:3000/api/v1';
        let currentNPCId = null;
        let npcList = [];

        // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
        function updateSliderValue(type) {
            const value = document.getElementById(`npc-${type}`).value;
            document.getElementById(`${type}-value`).textContent = parseFloat(value).toFixed(1);
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(message, type = 'info') {
            const log = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // æ›´æ–°æƒ…ç»ªæ˜¾ç¤º
        function updateEmotionDisplay(valence, arousal) {
            document.getElementById('emotion-valence').textContent = valence.toFixed(2);
            document.getElementById('emotion-arousal').textContent = arousal.toFixed(2);

            // æ›´æ–°ä»ªè¡¨
            const valencePercent = ((valence + 1) / 2) * 100;
            const arousalPercent = ((arousal + 1) / 2) * 100;

            document.getElementById('valence-meter').style.width = valencePercent + '%';
            document.getElementById('arousal-meter').style.width = arousalPercent + '%';

            // æ›´æ–°é¢œè‰²
            const valenceColor = valence > 0 ? '#10b981' : '#ef4444';
            const arousalColor = arousal > 0 ? '#f59e0b' : '#3b82f6';

            document.getElementById('valence-meter').style.background = valenceColor;
            document.getElementById('arousal-meter').style.background = arousalColor;

            // æ›´æ–°ç¯çŠ¶å›¾
            updateCircumplex(valence, arousal);
        }

        // æ›´æ–°ç¯çŠ¶å›¾
        function updateCircumplex(valence, arousal) {
            const point = document.getElementById('emotion-point');
            const tooltip = document.getElementById('emotion-tooltip');

            // è½¬æ¢åæ ‡ (-1,1) -> (0%, 100%)
            const x = ((valence + 1) / 2) * 100;
            const y = ((1 - arousal) / 2) * 100; // Yè½´åè½¬

            point.style.left = x + '%';
            point.style.top = y + '%';

            // æ›´æ–°æ‚¬æµ®å¡æ•°å€¼
            document.getElementById('tooltip-valence').textContent = valence.toFixed(2);
            document.getElementById('tooltip-arousal').textContent = arousal.toFixed(2);

            // æ˜¾ç¤ºæ‚¬æµ®å¡
            tooltip.classList.add('visible');

            // 3ç§’åéšè—
            setTimeout(() => {
                tooltip.classList.remove('visible');
            }, 3000);
        }

        // æ£€æŸ¥å¥åº·çŠ¶æ€
        async function checkHealth() {
            try {
                addLog('æ­£åœ¨æ£€æŸ¥æœåŠ¡å™¨å¥åº·çŠ¶æ€...');
                const response = await fetch('http://localhost:3000/health');
                const data = await response.json();

                document.getElementById('server-status').className = 'status connected';
                document.getElementById('server-status').textContent = 'å·²è¿æ¥';

                document.getElementById('health-response').style.display = 'block';
                document.getElementById('health-text').textContent = JSON.stringify(data, null, 2);

                addLog('âœ… æœåŠ¡å™¨å¥åº·æ£€æŸ¥é€šè¿‡');

                // åŠ è½½å·²æœ‰çš„ NPC åˆ—è¡¨
                await loadExistingNPCs();
            } catch (error) {
                document.getElementById('server-status').className = 'status disconnected';
                document.getElementById('server-status').textContent = 'è¿æ¥å¤±è´¥';
                addLog('âŒ æœåŠ¡å™¨è¿æ¥å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åŠ è½½å·²æœ‰çš„ NPC åˆ—è¡¨
        async function loadExistingNPCs() {
            try {
                addLog('æ­£åœ¨åŠ è½½å·²æœ‰ NPC åˆ—è¡¨...');
                const response = await fetch(API_BASE + '/npcs');
                const data = await response.json();

                if (data.success && Array.isArray(data.data)) {
                    npcList = data.data.map(npc => ({
                        id: npc.npc_id,
                        name: npc.name,
                        background: npc.background,
                        valence: npc.personality.valence,
                        arousal: npc.personality.arousal
                    }));

                    updateNPCSelect();
                    addLog(`âœ… åŠ è½½äº† ${npcList.length} ä¸ªå·²æœ‰ NPC`);
                } else {
                    addLog('ğŸ“‹ æš‚æ— å·²æœ‰ NPC');
                    npcList = [];
                    updateNPCSelect();
                }
            } catch (error) {
                addLog('âš ï¸  åŠ è½½ NPC åˆ—è¡¨å¤±è´¥: ' + error.message);
            }
        }

        // åˆå§‹åŒ–æ¨¡å‹
        async function initializeModel() {
            try {
                addLog('æ­£åœ¨åˆå§‹åŒ–ç¥ç»æ¨¡å‹...');
                document.getElementById('server-status').className = 'status waiting';
                document.getElementById('server-status').textContent = 'åˆå§‹åŒ–ä¸­...';

                const response = await fetch(API_BASE + '/initialize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                const data = await response.json();

                if (data.success) {
                    document.getElementById('server-status').className = 'status connected';
                    document.getElementById('server-status').textContent = 'æ¨¡å‹å·²å°±ç»ª';
                    addLog('âœ… ' + data.data.message);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                document.getElementById('server-status').className = 'status disconnected';
                document.getElementById('server-status').textContent = 'åˆå§‹åŒ–å¤±è´¥';
                addLog('âŒ æ¨¡å‹åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åˆ›å»º NPC
        async function createNPC() {
            try {
                const name = document.getElementById('npc-name').value;
                const background = document.getElementById('npc-background').value;
                const valence = parseFloat(document.getElementById('npc-valence').value);
                const arousal = parseFloat(document.getElementById('npc-arousal').value);
                const decayRate = parseFloat(document.getElementById('memory-decay').value);

                addLog(`æ­£åœ¨åˆ›å»º NPC: ${name}...`);

                const response = await fetch(API_BASE + '/npcs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: {
                            identity: {
                                name: name,
                                background: background
                            },
                            personality: {
                                valence: valence,
                                arousal: arousal
                            },
                            memory: {
                                decay_rate: decayRate
                            }
                        }
                    })
                });

                const data = await response.json();

                if (data.success) {
                    currentNPCId = data.data.npc_id;
                    document.getElementById('current-npc-id').value = currentNPCId;

                    npcList.push({
                        id: currentNPCId,
                        name: name,
                        background: background,
                        valence: valence,
                        arousal: arousal
                    });

                    updateNPCSelect();
                    addLog(`âœ… NPC åˆ›å»ºæˆåŠŸ: ${name} (${currentNPCId})`);

                    // æ˜¾ç¤ºåˆå§‹æƒ…ç»ª
                    updateEmotionDisplay(valence, arousal);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ NPC åˆ›å»ºå¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ›´æ–° NPC ä¸‹æ‹‰åˆ—è¡¨
        function updateNPCSelect() {
            const select = document.getElementById('npc-select');

            // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªå ä½ç¬¦ï¼‰
            select.innerHTML = '<option value="">-- è¯·é€‰æ‹©ä¸€ä¸ª NPC --</option>';

            // æ·»åŠ æ‰€æœ‰ NPC é€‰é¡¹
            npcList.forEach(npc => {
                const option = document.createElement('option');
                option.value = npc.id;
                option.textContent = `${npc.name} (${npc.id.substring(0, 8)}...)`;
                select.appendChild(option);
            });

            // å¦‚æœæœ‰å½“å‰é€‰ä¸­çš„ NPCï¼Œè®¾ç½®ä¸‹æ‹‰åˆ—è¡¨çš„å€¼
            if (currentNPCId) {
                select.value = currentNPCId;
            }
        }

        // ä¸‹æ‹‰åˆ—è¡¨é€‰æ‹©å˜æ›´å¤„ç†
        function onNPCSelectChange() {
            const select = document.getElementById('npc-select');
            const selectedId = select.value;

            if (selectedId) {
                selectNPC(selectedId);
            } else {
                currentNPCId = null;
                document.getElementById('current-npc-id').value = '';
                addLog('å·²å–æ¶ˆé€‰æ‹© NPC');
            }
        }

        // é€‰æ‹© NPC
        function selectNPC(npcId) {
            currentNPCId = npcId;
            document.getElementById('current-npc-id').value = npcId;
            document.getElementById('npc-select').value = npcId;

            const npc = npcList.find(n => n.id === npcId);
            if (npc) {
                // å¡«å……è¡¨å•å­—æ®µ
                document.getElementById('npc-name').value = npc.name;
                document.getElementById('npc-background').value = npc.background;
                document.getElementById('npc-valence').value = npc.valence;
                document.getElementById('npc-arousal').value = npc.arousal;

                // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
                document.getElementById('valence-value').textContent = npc.valence.toFixed(1);
                document.getElementById('arousal-value').textContent = npc.arousal.toFixed(1);

                // æ›´æ–°æƒ…ç»ªæ˜¾ç¤º
                updateEmotionDisplay(npc.valence, npc.arousal);

                addLog(`åˆ‡æ¢åˆ° NPC: ${npc.name}`);
            } else {
                addLog(`åˆ‡æ¢åˆ° NPC: ${npcId.substring(0, 8)}...`);
            }
        }

        // åˆ é™¤å½“å‰ NPC
        async function deleteCurrentNPC() {
            if (!currentNPCId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ª NPC å—ï¼Ÿ')) {
                return;
            }

            try {
                addLog(`æ­£åœ¨åˆ é™¤ NPC: ${currentNPCId}...`);

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    npcList = npcList.filter(npc => npc.id !== currentNPCId);
                    currentNPCId = null;
                    document.getElementById('current-npc-id').value = '';
                    updateNPCSelect();
                    addLog('âœ… NPC åˆ é™¤æˆåŠŸ');
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ NPC åˆ é™¤å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è¯„ä¼°äº¤äº’
        async function evaluateInteraction() {
            if (!currentNPCId) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–é€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            try {
                const text = document.getElementById('interaction-text').value;
                const sourceId = document.getElementById('source-id').value;

                addLog(`æ­£åœ¨è¯„ä¼°äº¤äº’: "${text.substring(0, 30)}..."`);

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId + '/evaluate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        source_id: sourceId || null
                    })
                });

                const data = await response.json();

                if (data.success) {
                    updateEmotionDisplay(data.data.valence, data.data.arousal);
                    addLog(`âœ… äº¤äº’è¯„ä¼°å®Œæˆ: Valence=${data.data.valence.toFixed(2)}, Arousal=${data.data.arousal.toFixed(2)}`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ äº¤äº’è¯„ä¼°å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–å½“å‰æƒ…ç»ª
        async function getCurrentEmotion() {
            if (!currentNPCId) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–é€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            try {
                addLog('æ­£åœ¨è·å–å½“å‰æƒ…ç»ª...');

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId + '/emotion');
                const data = await response.json();

                if (data.success) {
                    updateEmotionDisplay(data.data.valence, data.data.arousal);
                    addLog(`âœ… å½“å‰æƒ…ç»ª: Valence=${data.data.valence.toFixed(2)}, Arousal=${data.data.arousal.toFixed(2)}`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ è·å–æƒ…ç»ªå¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–ç‰¹å®šæ¥æºæƒ…ç»ª
        async function getEmotionBySource() {
            if (!currentNPCId) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–é€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            const sourceId = document.getElementById('source-id').value;
            if (!sourceId) {
                alert('è¯·è¾“å…¥æ¥æº ID');
                return;
            }

            try {
                addLog(`æ­£åœ¨è·å–å¯¹ "${sourceId}" çš„æƒ…ç»ª...`);

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId + '/emotion/' + sourceId);
                const data = await response.json();

                if (data.success) {
                    updateEmotionDisplay(data.data.valence, data.data.arousal);
                    addLog(`âœ… å¯¹ "${sourceId}" çš„æƒ…ç»ª: Valence=${data.data.valence.toFixed(2)}, Arousal=${data.data.arousal.toFixed(2)}`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ è·å–æƒ…ç»ªå¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–è®°å¿†
        async function getMemory() {
            if (!currentNPCId) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–é€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            try {
                addLog('æ­£åœ¨è·å–è®°å¿†...');

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId + '/memory');
                const data = await response.json();

                if (data.success) {
                    document.getElementById('memory-response').style.display = 'block';
                    document.getElementById('memory-text').textContent = JSON.stringify(data.data, null, 2);
                    addLog(`âœ… è·å–åˆ° ${Array.isArray(data.data) ? data.data.length : 0} æ¡è®°å¿†`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ è·å–è®°å¿†å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ¸…é™¤è®°å¿†
        async function clearMemory() {
            if (!currentNPCId) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–é€‰æ‹©ä¸€ä¸ª NPC');
                return;
            }

            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰è®°å¿†å—ï¼Ÿ')) {
                return;
            }

            try {
                addLog('æ­£åœ¨æ¸…é™¤è®°å¿†...');

                const response = await fetch(API_BASE + '/npcs/' + currentNPCId + '/memory', {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    addLog('âœ… è®°å¿†å·²æ¸…é™¤');
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                addLog('âŒ æ¸…é™¤è®°å¿†å¤±è´¥: ' + error.message, 'error');
            }
        }

        // é¼ æ ‡åœ¨æƒ…ç»ªç¯ä¸Šç§»åŠ¨æ—¶æ˜¾ç¤ºå¯¹åº”çš„æƒ…ç»ªæ•°å€¼
        function setupCircumplexHover() {
            const circumplex = document.getElementById('circumplex');
            const tooltip = document.getElementById('emotion-tooltip');
            const point = document.getElementById('emotion-point');

            circumplex.addEventListener('mousemove', function(e) {
                const rect = circumplex.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºä¸­å¿ƒçš„ä½ç½®
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„è·ç¦»
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius = centerX; // åœ†çš„åŠå¾„

                // åªåœ¨åœ†å†…æ—¶æ˜¾ç¤º
                if (distance <= radius) {
                    // è½¬æ¢ä¸º Valence å’Œ Arousal å€¼ (-1 åˆ° 1)
                    const valence = (dx / radius);
                    const arousal = -(dy / radius); // Yè½´åè½¬

                    // é™åˆ¶åœ¨ -1 åˆ° 1 ä¹‹é—´
                    const clampedValence = Math.max(-1, Math.min(1, valence));
                    const clampedArousal = Math.max(-1, Math.min(1, arousal));

                    // æ›´æ–°æ‚¬æµ®å¡æ•°å€¼
                    document.getElementById('tooltip-valence').textContent = clampedValence.toFixed(2);
                    document.getElementById('tooltip-arousal').textContent = clampedArousal.toFixed(2);

                    // å®šä½tooltipè·Ÿéšé¼ æ ‡ï¼Œåç§»ä¸€ç‚¹é¿å…é®æŒ¡
                    tooltip.style.left = (e.clientX + 20) + 'px';
                    tooltip.style.top = (e.clientY + 20) + 'px';

                    // æ˜¾ç¤ºæ‚¬æµ®å¡
                    tooltip.classList.add('visible');

                    // ä¸´æ—¶ç§»åŠ¨æƒ…ç»ªç‚¹åˆ°é¼ æ ‡ä½ç½®ï¼ˆåŠé€æ˜æ˜¾ç¤ºï¼‰
                    point.style.opacity = '0.5';
                    const percentX = (mouseX / rect.width) * 100;
                    const percentY = (mouseY / rect.height) * 100;
                    point.style.left = percentX + '%';
                    point.style.top = percentY + '%';
                } else {
                    // é¼ æ ‡åœ¨åœ†å¤–æ—¶éšè—
                    tooltip.classList.remove('visible');
                }
            });

            circumplex.addEventListener('mouseleave', function() {
                tooltip.classList.remove('visible');
                // æ¢å¤æƒ…ç»ªç‚¹çš„ä¸é€æ˜åº¦
                point.style.opacity = '1';
            });

            // ç‚¹å‡»æ—¶è®¾ç½®ä¸ºè¯¥ä½ç½®çš„æƒ…ç»ªï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
            circumplex.addEventListener('click', function(e) {
                const rect = circumplex.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius = centerX;

                if (distance <= radius) {
                    const valence = Math.max(-1, Math.min(1, dx / radius));
                    const arousal = Math.max(-1, Math.min(1, -(dy / radius)));

                    // æ›´æ–°æ˜¾ç¤º
                    updateEmotionDisplay(valence, arousal);
                    addLog(`ğŸ¯ æ‰‹åŠ¨è®¾ç½®æƒ…ç»ª: Valence=${valence.toFixed(2)}, Arousal=${arousal.toFixed(2)}`);

                    // æ¢å¤æƒ…ç»ªç‚¹çš„å®Œå…¨ä¸é€æ˜
                    point.style.opacity = '1';
                }
            });
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥å¥åº·çŠ¶æ€
        window.onload = function() {
            checkHealth();
            // åˆå§‹åŒ–æƒ…ç»ªç‚¹ä½ç½®ï¼ˆä¸­å¿ƒï¼‰
            updateCircumplex(0, 0);
            // è®¾ç½®æƒ…ç»ªç¯çš„é¼ æ ‡äº¤äº’
            setupCircumplexHover();
        };
    </script>
</body>
</html>
